import cudf
import json_repair
from utils.configs import get_llm
from prompts.plot_generation_template import generate_plots_prompt
import io
import re
from utils.utilities import is_timeseries, resample_df, get_dataframe
from typing import Optional, Dict, Any
import json
from .plot_generators import plot_scatter, plot_comparison_bars, plot_linear_regression, plot_violin, plot_ecdf, plot_parallel_coordinates, plot_pie, plot_time_series
import traceback


def get_llm_response(df: cudf.DataFrame, section_name: str) -> str:
    """
    Generates a response from a language model based on the structure of a given DataFrame.
    Args:
        df (cudf.DataFrame): The input DataFrame for which the response is to be generated.
        section_name (str): The name of the section to be included in the prompt.
    Returns:
        str: The response generated by the language model.
    The function performs the following steps:
    1. Extracts information about the DataFrame's structure and stores it in a buffer.
    2. Identifies numerical, categorical, and datetime columns in the DataFrame.
    3. Constructs a prompt by replacing placeholders with the identified column names and the provided section name.
    4. Sends the constructed prompt to a language model to generate a response.
    Note:
        - The function assumes the existence of a global variable `generate_plots_prompt` which contains the template for the prompt.
        - The function assumes the existence of a global object `llm` with a method `get_response` that takes a prompt and returns a response.
    """
    buffer = io.StringIO()
    df.info(buf=buffer)
    numerical_cols = df.select_dtypes(include=['float64', 'float32', 'int64', 'int32']).columns.tolist()
    categorical_cols = df.select_dtypes(include=['object', 'string']).columns.tolist()
    datetime_cols = df.select_dtypes(include=['datetime64', 'datetime64[ns]']).columns.tolist()
    
    if numerical_cols:
        numerical_cols_str = ", ".join(numerical_cols)
    else:
        numerical_cols_str = "None"
    if categorical_cols:
        categorical_cols_str = ", ".join(categorical_cols)
    else:
        categorical_cols_str = "None"
    if datetime_cols:
        datetime_cols_str = ", ".join(datetime_cols)
    else:
        datetime_cols_str = "None"
    
    # Replace placeholders with the corresponding strings
    prompt = generate_plots_prompt.replace("{numerical_columns}", numerical_cols_str)\
                                  .replace("{section_name}", section_name)\
                                  .replace("{categorical_columns}", categorical_cols_str)\
                                  .replace("{datetime_columns}", datetime_cols_str)
                                  
    print("CALLED LLM")
    llm = get_llm()
    return llm.get_response(prompt)

def extract_plot_config(response: str) -> Optional[str]:
    """
    Extracts a JSON-like configuration string from the given response.

    This function searches for a JSON-like object within the provided response string
    using a regular expression. If a match is found, the JSON-like string is returned;
    otherwise, None is returned.

    Args:
        response (str): The input string containing the response from which to extract the JSON-like configuration.

    Returns:
        Optional[str]: The extracted JSON-like configuration string if found, otherwise None.
    """
    match = re.search(r'\{.*\}', response, re.DOTALL)
    return match.group(0) if match else None

def validate_plot_config(plot_type: str, plot_config: Dict[str, Any]) -> Dict[str, Any]:
    """
    Validates and filters the plot configuration dictionary based on the plot type.
    Parameters:
    plot_type (str): The type of plot (e.g., 'scatter', 'bar', 'regression', etc.).
    plot_config (Dict[str, Any]): The configuration dictionary for the plot.
    Returns:
    Dict[str, Any]: A dictionary containing only the valid parameters for the specified plot type.
    """
    required_params = {
        'scatter': {'x', 'y', 'size', 'color'},
        'bar': {'x', 'y', 'color'},
        'regression': {'x', 'y'},
        'violin': {'x', 'y', 'color'},
        'ecdf': {'x', 'color'},
        'parallelcoordinates': set(),
        'pie': {'x', 'y'},
        'timeseries': {'x', 'y'},
        'heatmap': set()
    }
    
    valid_params = required_params.get(plot_type, set())
    return {k: v for k, v in plot_config.items() if k in valid_params}

async def parse_llm_response(section_name: str, max_samples: int = 10000):
    """
    Asynchronously parses the response from a language model to generate a plot.
    Args:
        section_name (str): The name of the section for which the plot is being generated.
        max_samples (int, optional): The maximum number of samples to use from the dataframe. Defaults to 10000.
    Returns:
        tuple: A tuple containing the plot object, the plot data in JSON format, and the plot configuration dictionary.
               If no plot is generated, returns (None, None, None).
    Raises:
        Exception: If any error occurs during the process, the exception traceback is printed and (None, None, None) is returned.
    """
    try:
        print("PLOT FACTORY CALLED")
        df = get_dataframe()
        if is_timeseries(df):
            df = resample_df(df)
            print("RESAMPLED DF")
        numeric_cols = df.select_dtypes(include=['float64', 'float32', 'int64', 'int32']).columns.tolist()
        for numeric_col in numeric_cols:
            df[numeric_col] = df[numeric_col].fillna(df[numeric_col].mean())
        df = df.drop_duplicates()
        print(f"DF AFTER DROP DUPLICATES: {df.shape}")   
        if len(df) > max_samples:
            df = df.sample(n=max_samples, random_state=42)  
            print(f"DF AFTER SAMPLING: {df.shape}")
        response = get_llm_response(df, section_name)
        print("LLM RESPONSE RECEIVED", response)
        plot_config_str = extract_plot_config(response)
        print("EXTRACTED PLOT CONFIG", plot_config_str) 
        if not plot_config_str:
            return None, None, None
        
        response_dict = json_repair.loads(plot_config_str)
        print("RESPONSE DICT", response_dict)
        plot_functions = {
            'scatter': plot_scatter,
            'bar': plot_comparison_bars,
            'regression': plot_linear_regression,
            'violin': plot_violin,
            'ecdf': plot_ecdf,
            'parallelcoordinates': plot_parallel_coordinates,
            'pie': plot_pie,
            'timeseries': plot_time_series
        }

        for plot_type, plot_function in plot_functions.items():
            if plot_type in response_dict:
                print(f"Generating plot for {section_name} using {plot_type} plot")
                plot_config = validate_plot_config(plot_type, response_dict[plot_type])
                print("VALIDATED PLOT CONFIG", plot_config)
                if plot_type == 'regression':
                    plot = plot_function(df, **plot_config, test_size=0.2)
                elif plot_type == 'parallelcoordinates':
                    plot = plot_function(df)
                    plot_config = {'type': 'parallelcoordinates'}
                else:
                    plot = plot_function(df, **plot_config)
                
                if plot:
                    try:
                        plot_data = json.loads(plot.to_json())
                        return plot, plot_data, plot_config
                    except json.JSONDecodeError:
                        print(traceback.format_exc())
                else:
                    print(f"Failed to generate plot for {section_name}")
        
        return None, None, None
    except Exception:
        print(traceback.format_exc())
        return None, None, None