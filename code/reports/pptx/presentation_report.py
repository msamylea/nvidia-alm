from pptx import Presentation
from io import BytesIO
import sys
import os
import base64
sys.path.append(os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
from utils.configs import get_llm
from prompts.presentation_prompt_template import presentation_prompt
import random
import re

def select_slide_layout(slide_content, include_plot, include_table):
    """
    Selects the appropriate slide layout based on the content and inclusion flags.

    Parameters:
    slide_content (dict): A dictionary containing the slide content with keys such as 'section_title', 'content', and 'report_title'.
    include_plot (bool): A flag indicating whether a plot should be included in the slide.
    include_table (bool): A flag indicating whether a table should be included in the slide.

    Returns:
    int: An integer representing the selected slide layout.
         - 0: Layout for report title.
         - 1: Default layout.
         - 2 or 3: Layouts for content with plot (randomly chosen).
         - 4: Layout for content with table.
    """
    if include_plot and include_table:
        include_table = False 
    if 'section_title' in slide_content and 'content' in slide_content:
        if include_table:
            return 4  
        elif include_plot:
            layout_choice = random.choice([2, 3])  
            return layout_choice
        else:
            return 1  
    elif 'report_title' in slide_content:
        return 0  
    else:
        return 1  

def get_presentation_content(content):
    """
    Generates a presentation content response using a language model.

    This function takes content, which is expected to be a dictionary, removes any key-value pairs where the key is 'plot_image',
    converts the dictionary to a string, and then uses a language model to generate a response based on a predefined prompt.

    Args:
        content (dict): The content to be included in the presentation. If the content is not a dictionary, it will be processed as is.

    Returns:
        str: The response generated by the language model based on the provided content.
    """
    if isinstance(content, dict):
        content = {k: v for k, v in content.items() if k != 'plot_image'}
        content = str(content)
    prompt = presentation_prompt.replace("{section_content}", content)
    llm = get_llm()
    response = llm.get_response(prompt)
    return response


def parse_slides(section_content):
    """
    Parses the given section content to extract slide information.
    Args:
        section_content (dict or str): The content of the section, either as a dictionary with a "content" key or as a string.
    Returns:
        list: A list of dictionaries, each representing a slide with the following keys:
            - 'report_title' (str or None): The title of the report, if present.
            - 'section_title' (str or None): The title of the section, if present.
            - 'content' (list): A list of dictionaries representing the content of the slide, where each dictionary has:
                - 'type' (str): The type of content, either 'bullet' or 'paragraph'.
                - 'text' (str): The text content.
            - 'table' (list or None): The parsed table content, if present, otherwise None.
    """
    if isinstance(section_content, dict):
        content = section_content.get("content", "")
    else:
        content = section_content
    
    if isinstance(content, list):
        content = "\n".join(content)  
    
    response = get_presentation_content(content)
    slides = []
    
    slide_pattern = re.compile(r'<Slide>(.*?)</Slide>', re.DOTALL)
    for slide_match in slide_pattern.finditer(response):
        slide_content = slide_match.group(1)
        
        report_title_match = re.search(r'<Report_Title>(.*?)</Report_Title>', slide_content, re.DOTALL)
        report_title = report_title_match.group(1) if report_title_match else None
        
        title_match = re.search(r'<Section_Title>(.*?)</Section_Title>', slide_content, re.DOTALL)
        section_title = title_match.group(1) if title_match else report_title
        
        content_match = re.search(r'<Content>(.*?)</Content>', slide_content, re.DOTALL)
        content = []
        if content_match:
            for line in content_match.group(1).strip().split('\n'):
                line = line.strip()
                if line.startswith('- '):
                    content.append({'type': 'bullet', 'text': line[2:].strip()})
                else:
                    content.append({'type': 'paragraph', 'text': line})
        
        table_match = re.search(r'<Table>(.*?)</Table>', slide_content, re.DOTALL)
        table = None
        if table_match:
            table_text = table_match.group(1).strip()
            table = parse_markdown_table(table_text)
        
        slide_data = {
            'report_title': report_title,
            'section_title': section_title,
            'content': content,
            'table': table,
        }
        
       
        slides.append(slide_data)
    
    return slides


def parse_markdown_table(markdown_table):
    """
    Parses a markdown table and returns its headers and data.
    Args:
        markdown_table (str): A string representation of a markdown table.
    Returns:
        dict: A dictionary with 'headers' and 'data' keys if the table is valid, 
              otherwise None. 'headers' is a list of column headers, and 'data' 
              is a list of rows, where each row is a list of cell values.
    """
    try:
        lines = markdown_table.strip().split('\n')
        if len(lines) < 3:  
            return None

        headers = [cell.strip() for cell in lines[0].split('|') if cell.strip()]
        data = []
        for line in lines[2:]:  
            cells = [cell.strip() for cell in line.split('|') if cell.strip()]
            if cells:
                data.append(cells)
        
        if not data:
            return None
        
        if headers and data:
            return {'headers': headers, 'data': data}
        else:
            return None
    except Exception as e:
        return None
    
def create_presentation(section_content, prs=None, selected_template='default'):
    """
    Creates a PowerPoint presentation based on the provided section content.
    Args:
        section_content (dict): A dictionary containing the content for the presentation sections.
            Expected keys include 'report_title', 'plot_image', and 'table'.
        prs (Presentation, optional): An existing Presentation object to add slides to. If None, a new
            presentation is created using the specified template. Defaults to None.
        selected_template (str, optional): The name of the template to use for the presentation. Defaults to 'default'.
    Returns:
        Presentation: The created or modified Presentation object.
    Notes:
        - If `prs` is None, a new presentation is created using the specified template.
        - If the presentation has no slides, a title slide is added with the 'report_title' from `section_content`.
        - Slides are created based on the parsed content from `section_content`.
        - If 'plot_image' is provided in `section_content`, it is added to the first slide that requires it.
        - Tables are added to slides if 'table' is provided in the corresponding section content.
    """
    if prs is None:
        if selected_template == 'default':
            prs = Presentation('templates/BlueYellow.pptx')
        else:
            prs = Presentation(f"templates/{selected_template}.pptx")
        
    if not prs.slides:
        title_slide = prs.slides.add_slide(prs.slide_layouts[0])
        report_title = title_slide.shapes.title
        report_title.text = section_content.get('report_title', 'Untitled Presentation')
    
    slides = parse_slides(section_content)
    plot_image = section_content.get('plot_image')
    
    for index, slide_content in enumerate(slides):
        slide_number = len(prs.slides) + 1
        include_plot = plot_image is not None
        include_table = slide_content.get('table') is not None
        
        layout_index = select_slide_layout(slide_content, include_plot=include_plot, include_table=include_table)
        slide = prs.slides.add_slide(prs.slide_layouts[layout_index])
        
        section_title = slide_content.get('section_title', 'Untitled Section')
        if section_title == 'Untitled Section' and 'report_title' in slide_content:
            section_title = slide_content['report_title']
        

        title_placeholder = slide.shapes.title
        if title_placeholder:
            title_placeholder.text = section_title
        else:
            return None
        
        add_content_to_slide(slide, slide_content)
        
        if include_table:
            add_table_to_slide(slide, slide_content['table'])
        
        if include_plot:
            add_plot_to_slide(slide, plot_image)
            plot_image = None

    return prs

def add_plot_to_slide(slide, plot_image):
    """
    Adds a plot image to a PowerPoint slide.

    Args:
        slide (pptx.slide.Slide): The slide to which the plot image will be added.
        plot_image (str): The plot image encoded as a base64 string.

    Returns:
        None: If the plot_image is empty or an error occurs during the process.
    """
    if not plot_image:
        return None

    try:
        plot_placeholder = find_plot_placeholder(slide)
        img_bytes = base64.b64decode(plot_image)
        plot_placeholder.insert_picture(BytesIO(img_bytes))
    except Exception as e:
        return None
        
def add_content_to_slide(slide, slide_content):
    """
    Adds content to a PowerPoint slide.

    This function finds the content placeholder in the given slide and adds
    paragraphs and bullet points based on the provided slide content.

    Args:
        slide (pptx.slide.Slide): The slide to which content will be added.
        slide_content (dict): A dictionary containing the content to be added.
            The dictionary should have a 'content' key, which is a list of
            dictionaries. Each dictionary in the list should have a 'type' key
            (either 'paragraph' or 'bullet') and a 'text' key with the content
            to be added.

    Example:
        slide_content = {
            'content': [
                {'type': 'paragraph', 'text': 'Introduction'},
                {'type': 'bullet', 'text': 'First point'},
                {'type': 'bullet', 'text': 'Second point'}
            ]
        }
        add_content_to_slide(slide, slide_content)
    """
    content_placeholder = find_content_placeholder(slide)
    text_frame = content_placeholder.text_frame
    text_frame.clear()  

    for item in slide_content['content']:
        if item['type'] == 'paragraph':
            p = text_frame.add_paragraph()
            p.text = item['text']
            p.level = 0
        elif item['type'] == 'bullet':
            p = text_frame.add_paragraph()
            p.text = item['text']
            p.level = 1

def add_plot_to_slide(slide, plot_image):
    """
    Adds a plot image to a slide.
    This function decodes a base64-encoded image and inserts it into a specified
    placeholder on the given slide. If the plot image is not provided or an error
    occurs during the process, the function returns None.
    Args:
        slide (Slide): The slide object where the plot image will be added.
        plot_image (str): The base64-encoded string of the plot image.
    Returns:
        None: If the plot image is not provided or an error occurs.
    """
    if not plot_image:
        return None

    try:
        plot_placeholder = find_plot_placeholder(slide)
        
        img_bytes = base64.b64decode(plot_image)
        plot_placeholder.insert_picture(BytesIO(img_bytes))
    except Exception as e:
        return None
    
def find_content_placeholder(slide):
    """
    Finds the first non-title placeholder in a given slide.

    Args:
        slide (pptx.slide.Slide): The slide object to search for placeholders.

    Returns:
        pptx.shapes.placeholder.Placeholder: The first non-title placeholder found, or None if no such placeholder exists.
    """
    for placeholder in slide.placeholders:
        if placeholder.placeholder_format.idx != 0:  
            return placeholder
    return None

def find_plot_placeholder(slide):
    """
    Finds and returns the first plot placeholder in the given slide.

    This function iterates through the placeholders in the provided slide and 
    checks if the placeholder type is one of the following:
    - 18: Chart Placeholder
    - 13: Picture Placeholder
    - 7: Content Placeholder

    If a matching placeholder is found, it is returned. If no matching 
    placeholder is found, the function returns None.

    Args:
        slide (pptx.slide.Slide): The slide object to search for plot placeholders.

    Returns:
        pptx.shapes.placeholder.Placeholder: The first matching plot placeholder 
        found in the slide, or None if no matching placeholder is found.
    """
    for shape in slide.placeholders:
        if shape.placeholder_format.type in [18, 13, 7]:  
            return shape
    return None

def find_table_placeholder(slide):
    """
    Finds and returns the table placeholder shape in a given slide.

    Args:
        slide (pptx.slide.Slide): The slide object to search for the table placeholder.

    Returns:
        pptx.shapes.placeholder.Placeholder: The table placeholder shape if found, otherwise None.
    """
    for shape in slide.placeholders:
        if shape.placeholder_format.type == 12: 
            return shape
    return None

def add_table_to_slide(slide, table_data):
    """
    Adds a table to a given slide in a PowerPoint presentation.
    Args:
        slide (pptx.slide.Slide): The slide to which the table will be added.
        table_data (dict): A dictionary containing the table headers and data.
            The dictionary should have the following structure:
            {
                'headers': [list of column headers],
                'data': [list of rows, where each row is a list of cell values]
            }
    Returns:
        None: If table_data is None or does not contain 'headers' or 'data' keys,
              or if an exception occurs during table insertion.
    """
    if table_data is None or 'headers' not in table_data or 'data' not in table_data:
        return
    try:
        table_placeholder = find_table_placeholder(slide)
        rows = len(table_data['data']) + 1  
        cols = len(table_data['headers'])
        
        table = table_placeholder.insert_table(rows, cols).table
        for col_idx, header in enumerate(table_data['headers']):
            table.cell(0, col_idx).text = header
        
        for row_idx, row in enumerate(table_data['data']):
            for col_idx, cell in enumerate(row):
                table.cell(row_idx + 1, col_idx).text = cell
    except Exception as e:
        return None